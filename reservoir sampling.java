2.在序列流中取一个数，如何确保随机性，即取出某个数据的概率为:1/(已读取数据个数)

　　假设已经读取n个数，现在保留的数是Ax，取到Ax的概率为(1/n)。

　　对于第n+1个数An+1，以1/(n+1)的概率取An+1，否则仍然取Ax。依次类推，可以保证取到数据的随机性。

　　数学归纳法证明如下：

　　　　当n=1时，显然，取A1。取A1的概率为1/1。

           假设当n=k时，取到的数据Ax。取Ax的概率为1/k。

           当n=k+1时，以1/(k+1)的概率取An+1，否则仍然取Ax。

　　　　(1)如果取Ak+1，则概率为1/(k+1)；

　　　　(2)如果仍然取Ax，则概率为(1/k)*(k/(k+1))=1/(k+1)

　　所以，对于之后的第n+1个数An+1，以1/(n+1)的概率取An+1，否则仍然取Ax。依次类推，可以保证取到数据的随机性
  
  
  public int getRandom(int[] nums) {
    int count = 0;
    int result = -1;
    Random rand = new Random();
    for (int i = 0; i < nums.length; i++) {
      if (result == -1) {
        count++;
        result = nums[i];
      } else {
        int rand = rand.nextInt(++count);
        if (rand == 0) {
          result = nums[i];
        }
      }
      return result;
    }
  }
  
  
  
  
  建立一个数组，将序列流里的前k个数，保存在数组中。(也就是所谓的"蓄水池")

　　对于第n个数An，以k/n的概率取An并以1/k的概率随机替换“蓄水池”中的某个元素；否则“蓄水池”数组不变。依次类推，可以保证取到数据的随机性。

　　数学归纳法证明如下：

　　　　当n=k是，显然“蓄水池”中任何一个数都满足，保留这个数的概率为k/k。

           假设当n=m(m>k)时，“蓄水池”中任何一个数都满足，保留这个数的概率为k/m。

           当n=m+1时，以k/(m+1)的概率取An，并以1/k的概率，随机替换“蓄水池”中的某个元素，否则“蓄水池”数组不变。则数组中保留下来的数的概率为：

　

　　所以，对于第n个数An，以k/n的概率取An并以1/k的概率随机替换“蓄水池”中的某个元素；否则“蓄水池”数组不变。依次类推，可以保证取到数据的随机性。


  
  
  public int[] getKRandom(int[] nums, int k) {
    int[] result = new int[k];
    Random rand = new Random();
    for (int i = 0; i < nums.length; i++) {
      if (i < k) {
        result[i] = nums[i]; 
      } else {
        int rand = rand.nextInt(i + 1);
        if (rand < k) {
          result[rand] = nums[i];
        }
      }
    }
    return result;
  }
  
解释一下：程序的开始就是把前k个元素都放到水库中，然后对之后的第i个元素，以k/i的概率替换掉这个水库中的某一个元素。
下面来具体证明一下：每个水库中的元素出现概率都是相等的。
【证明】
（1）初始情况。出现在水库中的k个元素的出现概率都是一致的，都是1。这个很显然。
（2）第一步。第一步就是指，处理第k+1个元素的情况。分两种情况：元素全部都没有被替换；其中某个元素被第k+1个元素替换掉。
我们先看情况2：第k+1个元素被选中的概率是k/(k+1)（根据公式k/i），所以这个新元素在水库中出现的概率就一定是k/(k+1)（不管它替换掉哪个元素，反正肯定它是以这个概率出现在水库中）。下面来看水库中剩余的元素出现的概率，也就是1-P(这个元素被替换掉的概率)。水库中任意一个元素被替换掉的概率是：(k/k+1)*(1/k)=1/(k+1)，意即首先要第k+1个元素被选中，然后自己在集合的k个元素中被选中。那它出现的概率就是1-1/(k+1)=k/(k+1)。可以看出来，旧元素和新元素出现的概率是相等的。
情况1：当元素全部都没有替换掉的时候，每个元素的出现概率肯定是一样的，这很显然。但具体是多少呢？就是1-P(第k+1个元素被选中)=1-k/(k+1)=1/(k+1)。
（3）归纳法：重复上面的过程，只要证明第i步到第i+1步，所有元素出现的概率是相等的即可。

看到一个问题：怎样随机从N个元素中选择一个元素，你依次遍历每个元素，但不知道N多大。
将N个元素用[1、2、...、N]编号。如果在知道N的大小，我们可以从[1、N]中随机选择一个数作为选择对象。
但是现在不知道N的大小，要使每一个元素被取的概率相等（随机）。这个概念叫蓄水池抽样。

Solution：以1/i的概率取第i个元素。
证明：数学归纳法。当i=1时：第1个元素以1/1=1的概率被取，符合条件。
设i=k时符合条件，即前k个元素都以1/k的概率被取。
则i=k+1时：对于第k+1个元素，被取概率为1/（k+1），符合条件。
对于前k个元素，每个元素被取的概率=被取并且没被第k+1个元素替换的概率=（1/k）*(1−1/（k+1）)=1/（k+1）符合条件。
综上所述：得证。

将问题扩展：给你一个长度为N的链表。N很大，但你不知道N有多大。你的任务是从这N个元素中随机取出k个元素。你只能遍历这个链表一次。你的算法必须保证取出的元素恰好有k个，且它们是完全随机的（出现概率均等）。
这次与上面唯一的不同是：总共需要取k个元素。仿照即可得出解决方案。
Solution：以1的概率取前k个元素，从i=k+1开始，以k/i的概率取第i个元素，若被取，以均等的概率替换先前被取的k个元素。
证明：同样数学归纳法。当i=k+1时：第k+1个元素以k/k+1概率被取，前k个元素被取的概率=1 - 被第k+1个元素替换的概率=1−k/(k+1)*1/k=k/(k+1) 符合条件。
设i=p时符合条件，即前p个元素都以k/p的概率被取。
则i=p+1时：对第p+1个元素，被取概率为k/(p+1)符合条件。
对于前p个元素，每个元素被取的概率=被取并且没有被第p+1个元素替换的概率=
k/p*((1−k/(p+1))+k/(p+1)*(1−1/k))=k/p+1同样符合条件。
综上所述：得证。

另外还有一种方法：给每个元素随机生成一个固定区间（如[0,1]）的权重。用一个大小为k的堆来选取权重较大的k个元素。仿照也可解决最开始的取1个的问题。
